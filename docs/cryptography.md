# Asheron's Call Protocol: ISAAC Cryptography

Asheron's Call uses the **ISAAC** (Indirection, Shift, Accumulate, Add, and Count) stream cipher to obfuscate packet checksums once a session is established.

## 1. Key Exchange
Two 4-byte seeds are exchanged during the handshake in the `ConnectRequest` (S2C) packet:
- **`ServerSeed`:** Used for the **Server-to-Client (S2C)** ISAAC stream.
- **`ClientSeed`:** Used for the **Client-to-Server (C2S)** ISAAC stream.

**Crucial Note:** These are TWO independent ISAAC instances. They MUST NOT share state.

## 2. Initialization (ACE Implementation)
The protocol uses a specific initialization sequence. Note that this differs from standard ISAAC initialization found in some libraries.

1.  Initialize state variables `a, b, c` to `0`.
2.  Initialize memory array `mm[256]` and result array `randRsl[256]` to `0`.
3.  Fill an 8-word array `abcdefgh` with the constant `0x9E3779B9`.
4.  Shuffle `abcdefgh` 4 times using the standard ISAAC shuffle.
5.  Mix `abcdefgh` into `mm` in two passes using the `randRsl` contents (initially 0).
6.  **Custom ACE Step:** Set the state variables `a`, `b`, and `c` all to the current seed's `uint32` value (e.g., `ClientSeed`).
7.  Run `IsaacScramble()` to generate the first 256 random values in `randRsl`.

### Key Generation logic
On ACE, there is no word-skipping. The `IsaacScramble()` call at the end of initialization populates the `randRsl` buffer.

1.  The `Next()` function returns the value at the current `offset` (starting at 255).
2.  The *first* packet to use encryption (after the handshake) will use the **last word** (index 255) of the first batch generated by `IsaacScramble()`.
3.  Every time a packet is sent or received with the `EncryptedChecksum` flag, the corresponding ISAAC instance must be updated by one word.

## 3. Checksum Calculation
Peers use wrapping 32-bit arithmetic for hashes and checksums.

- When a packet is sent with the `EncryptedChecksum` flag (`0x00000002`):
  1. Calculate `header_hash` (using the `PacketHeader` with checksum field = `0xBADD70DD`).
  2. Calculate `payload_hash` (Composite hash of all fragments and headers).
  3. Get the next value from the directional ISAAC: `key = ISAAC.Next()`.
  4. `Packet.Checksum = header_hash + (payload_hash ^ key)`. (Using wrapping 32-bit addition).

- The `ISAAC.Next()` function:
  1. Return `randRsl[index]`.
  2. Decrement `index`.
  3. If `index` becomes negative, run `IsaacScramble()` to refresh `randRsl` and reset `index` to `255`.

*(Note: The index starts at 255 and counts DOWN in the ACE implementation).*
